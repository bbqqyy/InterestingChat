# Interesting-Chat
整体项目结构采用了maven模块化，分为chat-server模块和chat-framework模块，chat-framework模块中又分为common-starter、transaction、oss-starter模块。
**chat-server：** 该模块负责主要的业务代码主要分为用户模块 websocket模块 消息模块。
**common：** 该模块主要是将各个模块所需要的包和工具类进行统一的管理，方便更好的拓展业务。
**transaction：** 该模块是负责使用rocketMQ来保证消息的可靠性以及设定的一些重试机制等
**oss-starter：** 主要是负责本地存储使用minIO来进行对象的存储
介绍完各个模块，就要讲一下技术选型了。
首先webSocket模块：主要是适应服务端推送消息的场景，
为什么采用这个websocket技术呢？
通过与http的短轮询和长轮询进行比较
**短轮询：** 首先是建立连接然后发送请求服务端如果有新消息就返回响应没有就返回空响应体，一是需要频繁建立连接，影响传输效率，二是有许多无效的请求浪费服务器资源。
**长轮询：** 相比于短轮询不需要频繁建立连接，但是长轮询在收到客户端请求后，服务器并不会马上返回新消息，而是将请求hold住直到有新消息产生或者等待超时。但依然会有许多超时没有返回消息的响应，再就是对后端资源轮询的压力没有减少，只是通过这种方式，将客户端一直发送请求的任务给了后端后端一直轮询是否有新消息的产生。
**websockt长连接：** 该连接允许后端主动推送消息给客户端，他们之间维持了一个TCP/IP长连接全双工通道
连接过程依然是客户端先发送HTTP握手然后后端进行webSocket协议通讯并告知websocket协议版本后端确认版本后，然后再将HTTP协议升级为WebSocket协议。
因此选型采用websocket并采用netty实现
那么为什么采用netty来实现呢？
相比于tomcat，netty是nio基于事件驱动的多路服用框架，可以使用单线程或少量线程处理大量的并发连接（虽然现在的Tomcat好像也支持了NIO）
重点是Netty提供了丰富的功能和组件，可以灵活的构建自定义的网络应用，而且又强大的编解码和处理器，可以轻松处理复杂的协议和数据格式，可以使用pipeline进行前置后置处理，也可以用netty的心跳处理器来检查连接状态。
心跳包是解决了服务端无法感知客户端是否还连接的，因此需要客户端维持心跳通过定时向服务端发送心跳包来维持连接，如果服务端超过设定事件没有收到心跳包，就会主动关闭连接。
### 扫码登录选型
面对这个问题，我的设计初衷是使用最简洁快速的方法来实现，我觉得没必要为了使用一个软件的时候，特意使用手机号等进行注册在登录，完全可以用现有的比如vx，qq之类的这种带有唯一OpenId的直接进行登录，如果是新用户完全可以通过授权的方式来获取一些用户基本信息比如头像、名称之类的。就简化了这个登录过程。
知道选型后，我们可以去引入微信登录的SDK，然后在配置文件中写一些配置参数，写配置类等基本工作。
因为需要微信任何事件都会发http通知到我们服务器，所以如果在本地调试时没有公网地址，就需要一个内网穿透工具进行配置
大致流程如下：
![image](https://github.com/user-attachments/assets/77111db1-c938-44d6-9230-d66b3a5176ab)
首先是用户进入到界面向后端请求登录二维码，然后后端生成随机code并保存和socket的映射，向vx平台申请临时二维码，然后像后端返回再传给前端，用户进行扫码登录，如果是第一次使用需要新进行注册，vx平台会进行回调服务器并携带着用户的openID和code，后端会向用户推送授权连接，用户点击后，vx平台会返回授权码，根据授权码获取accessToken然后根据它获取用户信息，后端再根据这些信息将用户基本信息填充完整，根据code匹配socket主动推送登陆成功
### 中心化管理token
为了能够控制JWT的上下线，主动下线，登陆续期等功能，对他进行中心化管理，使用redis存储uid->token的信息，确保一个uid只有一个有效的token用户登陆后，每一次认证都会解析出uid，并请求redis进行token比对。一部判断有效期小于一天进行续期，
### 幂等设计
首先这个聊天室会有一个勋章和改名卡的功能
具体的库表设计是当用户达到某些成就时，系统会根据它对应的成就颁发对应的勋章
用户表和物品表是一对多的关系因此添加一张背包表对应一个用户，一个背包中有多个物品
发放中有一个难以解决的问题：
在分布式场景下，发放物品是不能保证可靠，不可靠就要重试机制，重试如果没有保证幂等就可能发生多发的情况
幂等号可以由多个元素组合成，例如发放物品，幂等号可以是物品id+用户id+。。
幂等判断的三件套：
组装幂等号
加锁，分布式锁
重复校验
### IM顶层设计
![image](https://github.com/user-attachments/assets/738dc168-8c8e-423b-905b-ccb83669fbac)
**WebSocket**：维护和用户的连接通道，既能接收消息，也可以推送消息
**IM服务**：负责消息的发送逻辑，处理单聊群聊的消息
**Logic服务**：处理用户的心条，上下线，联系人，加好友，创建群等逻辑
**Auth服务**：处理用户认证，权限等需求
**Router**：推送消息时，不同用户在不同WebSocket服务上，确保正确推送，与可靠推送
交互流程大致如下：
用户A与WebSocket服务建立连接，之后都通过该连接发送消息，接受消息。
用户A发送消息，WebSocket服务将消息通过Dubbo转发给IM服务，由于IM服务时无状态的，可通过负载均衡随机发到某一台上，
IM服务将消息持久化，将消息投递到RocketMQ中，能快速响应前端，并且MQ的消费者根据负载慢慢进行后续的推送，写扩散等操作。
消费者会判断，根据是否热点群聊的消息做不同逻辑，如果是热点群聊，只写热点信箱，如果是单聊或者普通群聊，会写扩散到每个群成员信箱。
将消息投递信箱后，将消息推送给用户，根据是否在线，如果在线进行WebSocket推送，离线进行push通知，由于用户连接在不同的WebSocket上，需要Router服务推送到不同的WebSocket上
推送时要保证消息的可靠性，要做应用层的ACK类似tcp的滑动窗口确认


























